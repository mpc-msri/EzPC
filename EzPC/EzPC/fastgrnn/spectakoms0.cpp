/*
This is an autogenerated file, generated using the EzPC compiler.
*/
#include<vector>
#include<math.h>
#include<cstdlib>
#include<iostream>
#include<fstream>

using namespace std;

uint32_t public_lrshift(uint32_t x, uint32_t y){
return (x >> y);
}

int32_t public_lrshift(int32_t x, uint32_t y){
return ((int32_t)(((uint32_t)x) >> y));
}

uint64_t public_lrshift(uint64_t x, uint64_t y){
return (x >> y);
}

int64_t public_lrshift(int64_t x, uint64_t y){
return ((int64_t)(((uint64_t)x) >> y));
}

template<typename T>
vector<T> make_vector(size_t size) {
return std::vector<T>(size);
}

template <typename T, typename... Args>
auto make_vector(size_t first, Args... sizes)
{
auto inner = make_vector<T>(sizes...);
return vector<decltype(inner)>(first, inner);
}

template<typename T>
ostream& operator<< (ostream &os, const vector<T> &v)
{
for(auto it = v.begin (); it != v.end (); ++it) {
os << *it << endl;
}
return os;
}


#include "ezpc.h"
ABYParty *party;
Circuit* ycirc;
Circuit* acirc;
Circuit* bcirc;
uint32_t bitlen = 64;
output_queue out_q;
e_role role;
uint32_t nvals;

void MatMul(auto& a, auto& b, auto& c, int64_t i1, int64_t i2, int64_t i3){

share* sum = put_cons64_gate(acirc,  (int64_t)0);
for (uint32_t i =  (int64_t)0; i < i1; i++){
for (uint32_t j =  (int64_t)0; j < i2; j++){
sum = put_cons64_gate(acirc,  (int64_t)0);
for (uint32_t k =  (int64_t)0; k < i3; k++){
/* Temporary variable for sub-expression on source location: (11,33-11,40) */
share* __tac_var1 = a[i][k];
/* Temporary variable for sub-expression on source location: (11,43-11,50) */
share* __tac_var2 = b[k][j];

share* prod = acirc->PutMULGate(__tac_var1, __tac_var2);
sum = acirc->PutADDGate(sum, prod);
}
c[i][j] = sum;
}
}
}


int64_t ezpc_main (e_role role_param, char* address, uint16_t port, seclvl seclvl,
uint32_t nvals_param, uint32_t nthreads, e_mt_gen_alg mt_alg,
e_sharing sharing) {
role = role_param;
nvals = nvals_param;
party = new ABYParty(role_param, address, port, seclvl, bitlen, nthreads, mt_alg);
std::vector<Sharing*>& sharings = party->GetSharings();
ycirc = (sharings)[S_YAO]->GetCircuitBuildRoutine();
acirc = (sharings)[S_ARITH]->GetCircuitBuildRoutine();
bcirc = (sharings)[S_BOOL]->GetCircuitBuildRoutine();


auto W1 = make_vector<share*>( (int32_t)30,  (int32_t)8);
if ((role == SERVER)) {
cout << ("Input W1:") << endl;
}
/* Variable to read the clear value corresponding to the input variable W1 at (21,4-21,38) */
uint64_t __tmp_in_W1;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)30; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)8; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_W1;
}
W1[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_W1, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto W2 = make_vector<share*>( (int32_t)8,  (int32_t)64);
if ((role == SERVER)) {
cout << ("Input W2:") << endl;
}
/* Variable to read the clear value corresponding to the input variable W2 at (22,4-22,38) */
uint64_t __tmp_in_W2;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)8; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)64; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_W2;
}
W2[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_W2, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto U1 = make_vector<share*>( (int32_t)64,  (int32_t)8);
if ((role == SERVER)) {
cout << ("Input U1:") << endl;
}
/* Variable to read the clear value corresponding to the input variable U1 at (23,4-23,38) */
uint64_t __tmp_in_U1;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)64; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)8; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_U1;
}
U1[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_U1, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto U2 = make_vector<share*>( (int32_t)8,  (int32_t)64);
if ((role == SERVER)) {
cout << ("Input U2:") << endl;
}
/* Variable to read the clear value corresponding to the input variable U2 at (24,4-24,38) */
uint64_t __tmp_in_U2;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)8; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)64; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_U2;
}
U2[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_U2, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto Bg = make_vector<share*>( (int32_t)1,  (int32_t)64);
if ((role == SERVER)) {
cout << ("Input Bg:") << endl;
}
/* Variable to read the clear value corresponding to the input variable Bg at (25,4-25,38) */
uint64_t __tmp_in_Bg;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)64; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_Bg;
}
Bg[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_Bg, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto Bh = make_vector<share*>( (int32_t)1,  (int32_t)64);
if ((role == SERVER)) {
cout << ("Input Bh:") << endl;
}
/* Variable to read the clear value corresponding to the input variable Bh at (26,4-26,38) */
uint64_t __tmp_in_Bh;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)64; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_Bh;
}
Bh[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_Bh, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto FC1 = make_vector<share*>( (int32_t)64,  (int32_t)20);
if ((role == SERVER)) {
cout << ("Input FC1:") << endl;
}
/* Variable to read the clear value corresponding to the input variable FC1 at (27,4-27,40) */
uint64_t __tmp_in_FC1;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)64; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)20; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_FC1;
}
FC1[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_FC1, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto FC2 = make_vector<share*>( (int32_t)20,  (int32_t)72);
if ((role == SERVER)) {
cout << ("Input FC2:") << endl;
}
/* Variable to read the clear value corresponding to the input variable FC2 at (28,4-28,40) */
uint64_t __tmp_in_FC2;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)20; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)72; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_FC2;
}
FC2[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_FC2, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto FCBias = make_vector<share*>( (int32_t)1,  (int32_t)72);
if ((role == SERVER)) {
cout << ("Input FCBias:") << endl;
}
/* Variable to read the clear value corresponding to the input variable FCBias at (29,4-29,42) */
uint64_t __tmp_in_FCBias;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)72; i1++){
if ((role == SERVER)) {
cin >> __tmp_in_FCBias;
}
FCBias[i0][i1] = (role == SERVER) ? ycirc->PutINGate(__tmp_in_FCBias, bitlen, SERVER) : ycirc->PutDummyINGate(bitlen);
}
}

auto X = make_vector<share*>( (int32_t)210,  (int32_t)1);
if ((role == CLIENT)) {
cout << ("Input X:") << endl;
}
/* Variable to read the clear value corresponding to the input variable X at (31,4-31,38) */
uint64_t __tmp_in_X;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)210; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)1; i1++){
if ((role == CLIENT)) {
cin >> __tmp_in_X;
}
X[i0][i1] = (role == CLIENT) ? acirc->PutINGate(__tmp_in_X, bitlen, CLIENT) : acirc->PutDummyINGate(bitlen);
}
}

share* zeta = put_cons64_gate(acirc,  (int64_t)2623523);

share* nu = put_cons64_gate(acirc,  (int64_t)183599);

auto H = make_vector<share*>( (int32_t)64,  (int32_t)1);
for (uint32_t i =  (int32_t)0; i <  (int32_t)7; i++){

auto XX = make_vector<share*>( (int32_t)1,  (int32_t)30);
for (uint32_t j =  (int32_t)0; j <  (int32_t)30; j++){
XX[ (int32_t)0][j] = X[(( (int32_t)30 * i) + j)][ (int32_t)0];
}
}
party->ExecCircuit();
flush_output_queue(out_q, role, bitlen);
return 0;
}

