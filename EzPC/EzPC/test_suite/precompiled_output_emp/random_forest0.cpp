/*
This is an autogenerated file, generated using the EzPC compiler.
*/

#include "emp-sh2pc/emp-sh2pc.h" 
using namespace emp;
using namespace std;
int bitlen = 64;
int party,port;
char *ip = "127.0.0.1"; 
template<typename T> 
vector<T> make_vector(size_t size) { 
return std::vector<T>(size); 
} 

template <typename T, typename... Args> 
auto make_vector(size_t first, Args... sizes) 
{ 
auto inner = make_vector<T>(sizes...); 
return vector<decltype(inner)>(first, inner); 
} 

const uint32_t noOfFeatures =  (int32_t)13;

const uint32_t maxDepth =  (int32_t)11;

const int32_t maxDepthInt =  (int32_t)11;

const uint32_t noOfTrees =  (int32_t)10;

const uint32_t noOfNodes =  (int32_t)3035;

void accessElementOneD(auto& arr, Integer idx, auto& result){
result[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);

uint64_t ctr =  (uint64_t)0;
for (uint32_t i =  (int32_t)0; i <  (int32_t)13; i++){
/* Temporary variable for sub-expression on source location: (19,14-19,23) */
Integer __tac_var1 = result[ (int32_t)0];
/* Temporary variable for sub-expression on source location: (19,37-19,40) */
Integer __tac_var2 = Integer(bitlen, ctr, PUBLIC);
/* Temporary variable for sub-expression on source location: (19,30-19,40) */
Bit __tac_var3 = idx.operator==(__tac_var2);
/* Temporary variable for sub-expression on source location: (19,41-19,47) */
Integer __tac_var4 = arr[i];
/* Temporary variable for sub-expression on source location: (19,48-19,51) */
Integer __tac_var5 = Integer(bitlen,  (uint64_t)0, PUBLIC);
/* Temporary variable for sub-expression on source location: (19,30-19,51) */
Integer __tac_var6 =  If(__tac_var3, __tac_var4, __tac_var5);
result[ (int32_t)0] = __tac_var1.operator+(__tac_var6);
ctr = (ctr +  (uint64_t)1);
}
}

void accessElementTwoD(auto& arr, int64_t treeId, Integer idx, auto& result, uint32_t start, uint32_t end){
result[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);

uint64_t ctr =  (uint64_t)0;

Integer idxcpy = idx;
for (uint32_t i = start; i < end; i++){
/* Temporary variable for sub-expression on source location: (31,14-31,23) */
Integer __tac_var7 = result[ (int32_t)0];
/* Temporary variable for sub-expression on source location: (31,40-31,43) */
Integer __tac_var8 = Integer(bitlen, ctr, PUBLIC);
/* Temporary variable for sub-expression on source location: (31,30-31,43) */
Bit __tac_var9 = idxcpy.operator==(__tac_var8);
/* Temporary variable for sub-expression on source location: (31,44-31,58) */
Integer __tac_var10 = arr[treeId][i];
/* Temporary variable for sub-expression on source location: (31,59-31,62) */
Integer __tac_var11 = Integer(bitlen,  (uint64_t)0, PUBLIC);
/* Temporary variable for sub-expression on source location: (31,30-31,62) */
Integer __tac_var12 =  If(__tac_var9, __tac_var10, __tac_var11);
result[ (int32_t)0] = __tac_var7.operator+(__tac_var12);
ctr = (ctr +  (uint64_t)1);
}
}

uint32_t pow(uint32_t base, int32_t power){

uint32_t result =  (int32_t)1;
for (uint32_t i =  (int32_t)0; i < power; i++){
result = (result * base);
}
return result;
}

void infer(auto& modelFeatureChoice, auto& modelThresholdValue, auto& query, auto& result){

Integer currentIndex = Integer(bitlen,  (uint64_t)0, PUBLIC);

Integer leftOrRight = currentIndex;

auto currentSharedFeatureChoice = make_vector<Integer>( (int32_t)1);

auto currentSharedThreshold = make_vector<Integer>( (int32_t)1);

auto currentSharedQueryValue = make_vector<Integer>( (int32_t)1);
currentSharedFeatureChoice[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);
currentSharedThreshold[ (int32_t)0] = currentSharedFeatureChoice[ (int32_t)0];
currentSharedQueryValue[ (int32_t)0] = currentSharedFeatureChoice[ (int32_t)0];

uint32_t startIdx =  (int32_t)0;

uint32_t endIdx =  (int32_t)0;
for (uint32_t i =  (int32_t)0; i <  (int32_t)10; i++){
currentIndex = Integer(bitlen,  (uint64_t)0, PUBLIC);
currentSharedFeatureChoice[ (int32_t)0] = modelFeatureChoice[i][ (int32_t)0];
currentSharedThreshold[ (int32_t)0] = modelThresholdValue[i][ (int32_t)0];
/* Temporary variable for sub-expression on source location: (69,27-69,56) */
Integer __tac_var13 = currentSharedFeatureChoice[ (int32_t)0];
accessElementOneD(query, __tac_var13, currentSharedQueryValue);
/* Temporary variable for sub-expression on source location: (70,17-70,42) */
Integer __tac_var14 = currentSharedThreshold[ (int32_t)0];
/* Temporary variable for sub-expression on source location: (70,45-70,71) */
Integer __tac_var15 = currentSharedQueryValue[ (int32_t)0];
/* Temporary variable for sub-expression on source location: (70,17-70,71) */
Bit __tac_var16 = __tac_var14.operator>(__tac_var15);
/* Temporary variable for sub-expression on source location: (70,73-70,75) */
Integer __tac_var17 = Integer(bitlen,  (int64_t)1, PUBLIC);
/* Temporary variable for sub-expression on source location: (70,76-70,78) */
Integer __tac_var18 = Integer(bitlen,  (int64_t)2, PUBLIC);
/* Temporary variable for sub-expression on source location: (70,16-70,78) */
Integer __tac_var19 =  If(__tac_var16, __tac_var17, __tac_var18);
leftOrRight = __tac_var19;
/* Temporary variable for sub-expression on source location: (72,11-72,24) */
int32_t __tac_var20 = ( (int32_t)11 -  (int32_t)1);
for (uint32_t j =  (int32_t)1; j < __tac_var20; j++){
/* Temporary variable for sub-expression on source location: (74,37-74,40) */
Integer __tac_var21 = Integer(bitlen,  (uint64_t)2, PUBLIC);
/* Temporary variable for sub-expression on source location: (74,19-74,40) */
Integer __tac_var22 = currentIndex.operator*(__tac_var21);
currentIndex = __tac_var22.operator+(leftOrRight);
/* Temporary variable for sub-expression on source location: (75,14-75,24) */
uint32_t __tac_var23 = pow( (uint32_t)2, j);
startIdx = (__tac_var23 -  (uint32_t)1);
/* Temporary variable for sub-expression on source location: (76,20-76,23) */
int32_t __tac_var24 = (j +  (int32_t)1);
/* Temporary variable for sub-expression on source location: (76,12-76,24) */
uint32_t __tac_var25 = pow( (uint32_t)2, __tac_var24);
endIdx = (__tac_var25 -  (uint32_t)1);
accessElementTwoD(modelThresholdValue, i, currentIndex, currentSharedThreshold, startIdx, endIdx);
accessElementTwoD(modelFeatureChoice, i, currentIndex, currentSharedFeatureChoice, startIdx, endIdx);
/* Temporary variable for sub-expression on source location: (79,28-79,57) */
Integer __tac_var26 = currentSharedFeatureChoice[ (int32_t)0];
accessElementOneD(query, __tac_var26, currentSharedQueryValue);
/* Temporary variable for sub-expression on source location: (80,18-80,43) */
Integer __tac_var27 = currentSharedThreshold[ (int32_t)0];
/* Temporary variable for sub-expression on source location: (80,46-80,72) */
Integer __tac_var28 = currentSharedQueryValue[ (int32_t)0];
/* Temporary variable for sub-expression on source location: (80,18-80,72) */
Bit __tac_var29 = __tac_var27.operator>(__tac_var28);
/* Temporary variable for sub-expression on source location: (80,74-80,76) */
Integer __tac_var30 = __tac_var17;
/* Temporary variable for sub-expression on source location: (80,77-80,79) */
Integer __tac_var31 = __tac_var18;
/* Temporary variable for sub-expression on source location: (80,17-80,79) */
Integer __tac_var32 =  If(__tac_var29, __tac_var17, __tac_var18);
leftOrRight = __tac_var32;
}
/* Temporary variable for sub-expression on source location: (84,36-84,39) */
Integer __tac_var33 = Integer(bitlen,  (uint64_t)2, PUBLIC);
/* Temporary variable for sub-expression on source location: (84,18-84,39) */
Integer __tac_var34 = currentIndex.operator*(__tac_var33);
currentIndex = __tac_var34.operator+(leftOrRight);
/* Temporary variable for sub-expression on source location: (85,21-85,34) */
int32_t __tac_var35 = __tac_var20;
/* Temporary variable for sub-expression on source location: (85,13-85,35) */
uint32_t __tac_var36 = pow( (uint32_t)2, __tac_var20);
startIdx = (__tac_var36 -  (uint32_t)1);
/* Temporary variable for sub-expression on source location: (86,11-86,31) */
uint32_t __tac_var37 = pow( (uint32_t)2,  (int32_t)11);
endIdx = (__tac_var37 -  (uint32_t)1);
accessElementTwoD(modelThresholdValue, i, currentIndex, currentSharedThreshold, startIdx, endIdx);
result[i] = currentSharedThreshold[ (int32_t)0];
}
}


int main(int argc, char** argv) {
parse_party_and_port(argv, &party, &port);
if(argc>3){
  ip=argv[3];
}
cout<<"Ip Address: "<<ip<<endl;
cout<<"Port: "<<port<<endl;
cout<<"Party: "<<(party==1? "CLIENT" : "SERVER")<<endl;
NetIO * io = new NetIO(party==ALICE ? nullptr : ip, port);
setup_semi_honest(io, party);


auto inferenceQuery = make_vector<Integer>( (int32_t)13);

auto modelFeatureChoice = make_vector<Integer>( (int32_t)10,  (int32_t)3035);

auto modelThresholdValue = make_vector<Integer>( (int32_t)10,  (int32_t)3035);

auto inferenceResult = make_vector<Integer>( (int32_t)10);

Integer finalResult = Integer(bitlen,  (uint64_t)0, PUBLIC);
for (uint32_t i =  (int32_t)0; i <  (int32_t)13; i++){
inferenceQuery[i] = Integer(bitlen,  (uint64_t)20, PUBLIC);
}
for (uint32_t i =  (int32_t)0; i <  (int32_t)10; i++){
for (uint32_t j =  (int32_t)0; j <  (int32_t)3035; j++){
/* Temporary variable for sub-expression on source location: (114,31-114,57) */
uint32_t __tac_var38 = ( (int32_t)3035 %  (int32_t)13);
/* Temporary variable for sub-expression on source location: (114,30-114,62) */
uint64_t __tac_var39 = (__tac_var38 +  (uint64_t)0);
modelFeatureChoice[i][j] = Integer(bitlen, __tac_var39, PUBLIC);
/* Temporary variable for sub-expression on source location: (115,31-115,48) */
uint64_t __tac_var40 = ( (int32_t)3035 +  (uint64_t)351);
modelThresholdValue[i][j] = Integer(bitlen, __tac_var40, PUBLIC);
}
}
infer(modelFeatureChoice, modelThresholdValue, inferenceQuery, inferenceResult);
for (uint32_t i =  (int32_t)0; i <  (int32_t)10; i++){
/* Temporary variable for sub-expression on source location: (124,16-124,27) */
Integer __tac_var41 = finalResult;
/* Temporary variable for sub-expression on source location: (124,33-124,51) */
Integer __tac_var42 = inferenceResult[i];
/* Temporary variable for sub-expression on source location: (124,33-124,51) */
Integer __tac_var43 = __tac_var42;
/* Temporary variable for sub-expression on source location: (124,16-124,51) */
Integer __tac_var44 = __tac_var41.operator+(__tac_var43);
finalResult = __tac_var44;
}
cout << ("Value of finalResult:") << endl;
cout << (finalResult.reveal<uint64_t>(PUBLIC)) << endl;


finalize_semi_honest();
delete io; 
 
return 0;
}

